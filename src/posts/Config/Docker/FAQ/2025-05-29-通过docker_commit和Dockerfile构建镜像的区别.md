---
# 文章标题
title: 通过 docker commit 和 Dockerfile 构建镜像的区别
# 当前页面的短标题，会在导航栏、侧边栏和路径导航中作为首选。
shortTitle: 通过 docker commit 和 Dockerfile 构建镜像的区别
# 当前页面内容描述。
description: 通过docker_commit和Dockerfile构建镜像的区别
# 当前页面的图标，建议填写
icon: "/assets/blogicons/Docker.png"
# 作者
author: 
# 当前文章是否为原创
isOriginal: true
# 设置写作时间
date: 2025-05-29
# 分类，一个页面可以有多个分类
categories: 
  - Docker
# 标签，一个页面可以有多个标签
tags: 
  - docker commit
  - Dockerfile
# 页面的协议信息
license: CC BY-NC 4.0
# 置顶标记（true/false/数字），当填入数字时，数字越大，排名越靠前。
sticky: false
# 星标（true/false/数字），当填入数字时，数字越大，排名越靠前。
star: true
# 是否将该文章添加至文章列表中。
article: true
# 是否将该文章添加至时间线中。
timeline: true
# 是否开启评论
comment: false
# 预览图。请填入绝对路径。图片路径位于 .vuepress/public 下
# cover: /assets/images/cover1.jpg
# 设置横幅图片 (宽屏分享图)，请填入绝对路径。
# banner: /assets/images/cover1.jpg
---

## **1. 两种容器镜像的构建方法**

1. 通过 docker commit 将正在运行的容器保存成镜像。
2. 通过 Dockerfile 自动化构建镜像。

## **2. 通过 docker commit 生成镜像**

### **2.1 基本构建方法**

1. 拉取原始镜像
2. 将镜像作为容器运行起来（`docker run image:tag`）
3. 进入容器中执行操作（`docker exec -it container /bin/bash`）
4. 将容器保存成镜像（`docker commit container new_image:tag`）

### **2.2 优点**

1. **操作简单，易上手**。
2. **灵活性高**：可以在容器内进行任意修改，非常适合实验和调试。
3. **构建速度快**。
4. **镜像制作效率高，体积小**：所有的操作全部在同一个操作层内完成，==在注重清理残留数据和敏感文件的前提下==，可以有效控制镜像体积（但操作难度大，对制作者的能力要求高）。

### 2.3 缺点

1. **可维护性差**：对镜像的所有操作都是黑箱操作，生成的镜像也被称为黑箱镜像。除了制作镜像的人，其他人无法得知镜像内部做过什么操作，即便是制作镜像的人，在一段时间之后也无法记清具体的操作行为。需要手工编写文档记录操作内容。
2. **一致性差**：不同的制作者制作出来的镜像不完全一致，即便是同一个人制作的两个镜像，也可能不完全一致，镜像的最终效果呈现出强烈的个人色彩。
3. **镜像体积与安全性**：如果能一次制作完成，并完成临时文件的清理和敏感数据的清除，那么镜像的效果和体积都是最优的。==**但如果多次修改，多次 commit 就会导致镜像大小飞速增长，并且会在镜像内遗留临时文件和敏感数据。**==
4. **容易残留无用数据/敏感文件**：每次制作完成需要及时清理无用数据，如果一旦将无用数据保存到了镜像内，那么这些数据就会始终留存在镜像中。（即便后面通过第二次 commit 删掉了无用数据，存储空间也不会释放，因为数据位于不同的操作层中。）

::: note
docker 镜像采用分层存储的方式，每次操作都是在当前层进行标记、添加、修改，而不会改动上一层的数据。因此，如果在第一层中引入了无用数据，即便在第二层中对数据进行了删除，也并没有在镜像中真实的删除该数据，只是在第二层中将数据标记为删除，看不到了而已。在第一层中这些数据仍然还是存在的。
:::

### 2.4 适用场景

通常适用于实验、测试、开发、调试等临时使用的场景。

## 3. 通过 Dockerfile 构建镜像

### 3.1 基本构建方法

1. 拉取原始镜像
2. 编写 Dockerfile 脚本
3. 使用 Dockerfile 脚本构建镜像（`docker build -f /tmp/Dockerfile -t new_image:tag /tmp/`）

### 3.2 优点

1. **一致性**：只需编写一次 Dockerfile，即可多次重复构建镜像，确保镜像一致性。
2. **可维护性强**：Dockerfile 的指令清晰，便于后续维护。
3. **版本控制**：可以与代码一起进行版本控制，便于追踪变更。

### 3.3 缺点

1. **灵活性不足**：对于一些复杂的构建场景，Dockerfile 可能难以满足需求，届时需考虑分阶段构建或其他方法。
2. **构建速度慢**：每次构建都需要从头开始，构建过程中可能需要多次微调，每次微调都需要重新构建镜像后才能测试验证，因此会拖慢整体构建速度。
3. **镜像体积难以控制**：Dockerfile 中每次执行 `RUN` 命令都会增加一个操作层，如果配置不好同样会造成镜像体积过大，需要多次调整优化，减少操作层。
4. **上手难度大**：需要制作者有一定的脚本基础。另外，需要镜像制作者在每一个操作层中及时清理临时文件和敏感文件，避免带入下一个操作层中，同样需要镜像制作者具备较高的经验和能力水平。

### 3.4 适用场景

通常适用于生产环境制作正式发布的镜像。

## 4. 总结

==**总结来看，docker commit 方式制作的镜像和使用 Dockerfile 制作的镜像在本质上没有区别。**==

相对比而言，docker commit 制作的镜像有较高的不确定性，镜像的好坏全依赖镜像制作者的能力水平和经验，并且由于是黑箱镜像，镜像后续的可维护性差，安全风险高（难以避免镜像制作者在镜像内留有后门）。因此在生产环境下通常不建议采用 docker commit 方式生成镜像。

Dockerfile 的流程清晰，可扩展性强，构建出来的镜像可以保持较高的一致性，另外通过优化 Dockerfile 的流程可以提高安全性，降低体积，最终得到不逊于 docker commit 制作的镜像，是生产环境中制作容器镜像的最佳方式。

以下是 docker commit 方式制作镜像和使用 dockerfile 方式制作镜像的核心差异点。

| 维度 | docker commit | Dockerfile |
| :---: | :--- | :--- |
| 构建方式 | 手工操作容器 | 声明式自动化构建 |
| 可维护性 | 无版本记录，难追溯 | 完整构建历史，Git 可管理 |
| 镜像体积 | 难以管理。可能很小，也可能很大，依赖镜像制作者的经验 | 镜像体积不会出现太大浮动，可通过优化 Dockerfile 脚本和构建方式降低大小 |
| 安全风险 | 易残留敏感文件/临时文件 | 可控构建过程，可通过优化 Dockerfile 脚本和构建方式降低安全风险 |
| CI/CD 支持 | 不支持 | 原生支持自动化构建 |
| 构建速度 | 快 | 慢 |
| 团队协作 | 依赖人工文档 | 代码即文档 |

## 5. 生产环境中的最佳实践

==**在生产环境中，通常在前期使用 docker commit 进行测试验证，随后根据验证结果编写 dockerfile 脚本制作标准镜像。最后部署到生产环境中再根据不同的需求使用 docker commit 微调。**==

生产环境的镜像构建必须遵循：

1. **零 Commit 原则**：禁止直接提交容器为镜像。
2. **可重复构建**：任何镜像必须通过 Dockerfile 生成。
3. **最小化原则**：多阶段构建 + 安全扫描。

建议将镜像构建规范写入 CI/CD 门禁系统，对于历史遗留的 通过 docker commit 提交的镜像，建议尽快完成 Dockerfile 化改造。

## 6. 参考

1. 《使用Dockerfile与commit命令：探索Docker构建镜像的两种高效方法》 https://www.oryoy.com/news/shi-yong-dockerfile-yu-commit-ming-ling-tan-suo-docker-gou-jian-jing-xiang-de-liang-zhong-gao-xiao-f.html
2. 《docker commit 和docker build （实战使用以及区别）》 https://blog.csdn.net/alwaysbefine/article/details/111375658
3. 《Docker镜像构建双刃剑：Commit与Dockerfile生产抉择指南》 https://www.cnblogs.com/leojazz/p/18789384
4. 《Dockerfile最小化构建镜像：减少层数、清理无用数据、多段构建》 https://blog.csdn.net/qq_39213171/article/details/107789804