import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as r,o as i}from"./app-BICfmULO.js";const l={};function a(n,e){return i(),o("div",null,e[0]||(e[0]=[r('<h2 id="_1-两种容器镜像的构建方法" tabindex="-1"><a class="header-anchor" href="#_1-两种容器镜像的构建方法"><span><strong>1. 两种容器镜像的构建方法</strong></span></a></h2><ol><li>通过 docker commit 将正在运行的容器保存成镜像。</li><li>通过 Dockerfile 自动化构建镜像。</li></ol><h2 id="_2-通过-docker-commit-生成镜像" tabindex="-1"><a class="header-anchor" href="#_2-通过-docker-commit-生成镜像"><span><strong>2. 通过 docker commit 生成镜像</strong></span></a></h2><h3 id="_2-1-基本构建方法" tabindex="-1"><a class="header-anchor" href="#_2-1-基本构建方法"><span><strong>2.1 基本构建方法</strong></span></a></h3><ol><li>拉取原始镜像</li><li>将镜像作为容器运行起来（<code>docker run image:tag</code>）</li><li>进入容器中执行操作（<code>docker exec -it container /bin/bash</code>）</li><li>将容器保存成镜像（<code>docker commit container new_image:tag</code>）</li></ol><h3 id="_2-2-优点" tabindex="-1"><a class="header-anchor" href="#_2-2-优点"><span><strong>2.2 优点</strong></span></a></h3><ol><li><strong>操作简单，易上手</strong>。</li><li><strong>灵活性高</strong>：可以在容器内进行任意修改，非常适合实验和调试。</li><li><strong>构建速度快</strong>。</li><li><strong>镜像制作效率高，体积小</strong>：所有的操作全部在同一个操作层内完成，<mark>在注重清理残留数据和敏感文件的前提下</mark>，可以有效控制镜像体积（但操作难度大，对制作者的能力要求高）。</li></ol><h3 id="_2-3-缺点" tabindex="-1"><a class="header-anchor" href="#_2-3-缺点"><span>2.3 缺点</span></a></h3><ol><li><strong>可维护性差</strong>：对镜像的所有操作都是黑箱操作，生成的镜像也被称为黑箱镜像。除了制作镜像的人，其他人无法得知镜像内部做过什么操作，即便是制作镜像的人，在一段时间之后也无法记清具体的操作行为。需要手工编写文档记录操作内容。</li><li><strong>一致性差</strong>：不同的制作者制作出来的镜像不完全一致，即便是同一个人制作的两个镜像，也可能不完全一致，镜像的最终效果呈现出强烈的个人色彩。</li><li><strong>镜像体积与安全性</strong>：如果能一次制作完成，并完成临时文件的清理和敏感数据的清除，那么镜像的效果和体积都是最优的。<mark><strong>但如果多次修改，多次 commit 就会导致镜像大小飞速增长，并且会在镜像内遗留临时文件和敏感数据。</strong></mark></li><li><strong>容易残留无用数据/敏感文件</strong>：每次制作完成需要及时清理无用数据，如果一旦将无用数据保存到了镜像内，那么这些数据就会始终留存在镜像中。（即便后面通过第二次 commit 删掉了无用数据，存储空间也不会释放，因为数据位于不同的操作层中。）</li></ol><div class="hint-container note"><p class="hint-container-title">注</p><p>docker 镜像采用分层存储的方式，每次操作都是在当前层进行标记、添加、修改，而不会改动上一层的数据。因此，如果在第一层中引入了无用数据，即便在第二层中对数据进行了删除，也并没有在镜像中真实的删除该数据，只是在第二层中将数据标记为删除，看不到了而已。在第一层中这些数据仍然还是存在的。</p></div><h3 id="_2-4-适用场景" tabindex="-1"><a class="header-anchor" href="#_2-4-适用场景"><span>2.4 适用场景</span></a></h3><p>通常适用于实验、测试、开发、调试等临时使用的场景。</p><h2 id="_3-通过-dockerfile-构建镜像" tabindex="-1"><a class="header-anchor" href="#_3-通过-dockerfile-构建镜像"><span>3. 通过 Dockerfile 构建镜像</span></a></h2><h3 id="_3-1-基本构建方法" tabindex="-1"><a class="header-anchor" href="#_3-1-基本构建方法"><span>3.1 基本构建方法</span></a></h3><ol><li>拉取原始镜像</li><li>编写 Dockerfile 脚本</li><li>使用 Dockerfile 脚本构建镜像（<code>docker build -f /tmp/Dockerfile -t new_image:tag /tmp/</code>）</li></ol><h3 id="_3-2-优点" tabindex="-1"><a class="header-anchor" href="#_3-2-优点"><span>3.2 优点</span></a></h3><ol><li><strong>一致性</strong>：只需编写一次 Dockerfile，即可多次重复构建镜像，确保镜像一致性。</li><li><strong>可维护性强</strong>：Dockerfile 的指令清晰，便于后续维护。</li><li><strong>版本控制</strong>：可以与代码一起进行版本控制，便于追踪变更。</li></ol><h3 id="_3-3-缺点" tabindex="-1"><a class="header-anchor" href="#_3-3-缺点"><span>3.3 缺点</span></a></h3><ol><li><strong>灵活性不足</strong>：对于一些复杂的构建场景，Dockerfile 可能难以满足需求，届时需考虑分阶段构建或其他方法。</li><li><strong>构建速度慢</strong>：每次构建都需要从头开始，构建过程中可能需要多次微调，每次微调都需要重新构建镜像后才能测试验证，因此会拖慢整体构建速度。</li><li><strong>镜像体积难以控制</strong>：Dockerfile 中每次执行 <code>RUN</code> 命令都会增加一个操作层，如果配置不好同样会造成镜像体积过大，需要多次调整优化，减少操作层。</li><li><strong>上手难度大</strong>：需要制作者有一定的脚本基础。另外，需要镜像制作者在每一个操作层中及时清理临时文件和敏感文件，避免带入下一个操作层中，同样需要镜像制作者具备较高的经验和能力水平。</li></ol><h3 id="_3-4-适用场景" tabindex="-1"><a class="header-anchor" href="#_3-4-适用场景"><span>3.4 适用场景</span></a></h3><p>通常适用于生产环境制作正式发布的镜像。</p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span>4. 总结</span></a></h2><p><mark><strong>总结来看，docker commit 方式制作的镜像和使用 Dockerfile 制作的镜像在本质上没有区别。</strong></mark></p><p>相对比而言，docker commit 制作的镜像有较高的不确定性，镜像的好坏全依赖镜像制作者的能力水平和经验，并且由于是黑箱镜像，镜像后续的可维护性差，安全风险高（难以避免镜像制作者在镜像内留有后门）。因此在生产环境下通常不建议采用 docker commit 方式生成镜像。</p><p>Dockerfile 的流程清晰，可扩展性强，构建出来的镜像可以保持较高的一致性，另外通过优化 Dockerfile 的流程可以提高安全性，降低体积，最终得到不逊于 docker commit 制作的镜像，是生产环境中制作容器镜像的最佳方式。</p><p>以下是 docker commit 方式制作镜像和使用 dockerfile 方式制作镜像的核心差异点。</p><table><thead><tr><th style="text-align:center;">维度</th><th style="text-align:left;">docker commit</th><th style="text-align:left;">Dockerfile</th></tr></thead><tbody><tr><td style="text-align:center;">构建方式</td><td style="text-align:left;">手工操作容器</td><td style="text-align:left;">声明式自动化构建</td></tr><tr><td style="text-align:center;">可维护性</td><td style="text-align:left;">无版本记录，难追溯</td><td style="text-align:left;">完整构建历史，Git 可管理</td></tr><tr><td style="text-align:center;">镜像体积</td><td style="text-align:left;">难以管理。可能很小，也可能很大，依赖镜像制作者的经验</td><td style="text-align:left;">镜像体积不会出现太大浮动，可通过优化 Dockerfile 脚本和构建方式降低大小</td></tr><tr><td style="text-align:center;">安全风险</td><td style="text-align:left;">易残留敏感文件/临时文件</td><td style="text-align:left;">可控构建过程，可通过优化 Dockerfile 脚本和构建方式降低安全风险</td></tr><tr><td style="text-align:center;">CI/CD 支持</td><td style="text-align:left;">不支持</td><td style="text-align:left;">原生支持自动化构建</td></tr><tr><td style="text-align:center;">构建速度</td><td style="text-align:left;">快</td><td style="text-align:left;">慢</td></tr><tr><td style="text-align:center;">团队协作</td><td style="text-align:left;">依赖人工文档</td><td style="text-align:left;">代码即文档</td></tr></tbody></table><h2 id="_5-生产环境中的最佳实践" tabindex="-1"><a class="header-anchor" href="#_5-生产环境中的最佳实践"><span>5. 生产环境中的最佳实践</span></a></h2><p><mark><strong>在生产环境中，通常在前期使用 docker commit 进行测试验证，随后根据验证结果编写 dockerfile 脚本制作标准镜像。最后部署到生产环境中再根据不同的需求使用 docker commit 微调。</strong></mark></p><p>生产环境的镜像构建必须遵循：</p><ol><li><strong>零 Commit 原则</strong>：禁止直接提交容器为镜像。</li><li><strong>可重复构建</strong>：任何镜像必须通过 Dockerfile 生成。</li><li><strong>最小化原则</strong>：多阶段构建 + 安全扫描。</li></ol><p>建议将镜像构建规范写入 CI/CD 门禁系统，对于历史遗留的 通过 docker commit 提交的镜像，建议尽快完成 Dockerfile 化改造。</p><h2 id="_6-参考" tabindex="-1"><a class="header-anchor" href="#_6-参考"><span>6. 参考</span></a></h2><ol><li>《使用Dockerfile与commit命令：探索Docker构建镜像的两种高效方法》 <a href="https://www.oryoy.com/news/shi-yong-dockerfile-yu-commit-ming-ling-tan-suo-docker-gou-jian-jing-xiang-de-liang-zhong-gao-xiao-f.html" target="_blank" rel="noopener noreferrer">https://www.oryoy.com/news/shi-yong-dockerfile-yu-commit-ming-ling-tan-suo-docker-gou-jian-jing-xiang-de-liang-zhong-gao-xiao-f.html</a></li><li>《docker commit 和docker build （实战使用以及区别）》 <a href="https://blog.csdn.net/alwaysbefine/article/details/111375658" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/alwaysbefine/article/details/111375658</a></li><li>《Docker镜像构建双刃剑：Commit与Dockerfile生产抉择指南》 <a href="https://www.cnblogs.com/leojazz/p/18789384" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/leojazz/p/18789384</a></li><li>《Dockerfile最小化构建镜像：减少层数、清理无用数据、多段构建》 <a href="https://blog.csdn.net/qq_39213171/article/details/107789804" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_39213171/article/details/107789804</a></li></ol>',34)]))}const d=t(l,[["render",a]]),m=JSON.parse('{"path":"/posts/Config/Docker/FAQ/2025-05-29-%E9%80%9A%E8%BF%87docker_commit%E5%92%8CDockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"通过 docker commit 和 Dockerfile 构建镜像的区别","lang":"zh-CN","frontmatter":{"title":"通过 docker commit 和 Dockerfile 构建镜像的区别","shortTitle":"通过 docker commit 和 Dockerfile 构建镜像的区别","description":"通过docker_commit和Dockerfile构建镜像的区别","icon":"/assets/blogicons/Docker.png","author":null,"isOriginal":true,"date":"2025-05-29T00:00:00.000Z","categories":["Docker"],"tags":["docker commit","Dockerfile"],"license":"CC BY-NC 4.0","sticky":false,"star":true,"article":true,"timeline":true,"comment":false,"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"通过 docker commit 和 Dockerfile 构建镜像的区别\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-05-29T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-09T11:46:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"昌霖学长\\",\\"email\\":\\"shawnlyu1990@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://shawnlyu1990.github.io/posts/Config/Docker/FAQ/2025-05-29-%E9%80%9A%E8%BF%87docker_commit%E5%92%8CDockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E7%9A%84%E5%8C%BA%E5%88%AB.html"}],["meta",{"property":"og:site_name","content":"昌霖学长的自习室"}],["meta",{"property":"og:title","content":"通过 docker commit 和 Dockerfile 构建镜像的区别"}],["meta",{"property":"og:description","content":"通过docker_commit和Dockerfile构建镜像的区别"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-09T11:46:07.000Z"}],["meta",{"property":"article:tag","content":"Dockerfile"}],["meta",{"property":"article:tag","content":"docker commit"}],["meta",{"property":"article:published_time","content":"2025-05-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-09T11:46:07.000Z"}]]},"git":{"createdTime":1749469567000,"updatedTime":1749469567000,"contributors":[{"name":"Shawn Lyu","username":"","email":"shawnlyu1990@gmail.com","commits":1}]},"readingTime":{"minutes":7.04,"words":2111},"filePathRelative":"posts/Config/Docker/FAQ/2025-05-29-通过docker_commit和Dockerfile构建镜像的区别.md","excerpt":"","copyright":{"license":"CC BY-NC 4.0"}}');export{d as comp,m as data};
