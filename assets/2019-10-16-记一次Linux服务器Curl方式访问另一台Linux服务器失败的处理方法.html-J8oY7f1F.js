import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as s,o as a}from"./app--kRYgpm7.js";const n={};function l(p,i){return a(),e("div",null,i[0]||(i[0]=[s(`<h2 id="问题现象" tabindex="-1"><a class="header-anchor" href="#问题现象"><span>问题现象</span></a></h2><p><strong>背景</strong>：<br> 内网的 Linux 服务器 A 日常需要通过 <code>curl</code> 命令连接公网的 Linux 服务器 B，传输数据并执行脚本。A 连接 B 的时候过了一个 SNAT 转换。</p><p>某日突然发现服务器 A <code>curl</code> 连接服务器 B 失败，但 <code>ping</code> 服务器 B 可通，<code>telnet</code> 443 端口也正常，检查服务器 A 和 B 的配置情况，没有修改痕迹。</p><p>执行 <code>curl -v https://&lt;服务器B的域名&gt;</code> 命令，发现走到 <code>client hello</code> 之后就不往下走了</p><p>苦恼了许久，最后在 Google 上找到了解决办法。特此记录</p><h2 id="问题原因-解决方法" tabindex="-1"><a class="header-anchor" href="#问题原因-解决方法"><span>问题原因 &amp; 解决方法</span></a></h2><p><strong>问题原因</strong>：</p><p>当客户端发出的 syn 包带有时间戳的情况下，经过 NAT 转换后，如果使用的端口被之前使用过，而且时间戳大于本次 syn 包中的时间戳。系统将会直接丢弃。造成本次链接无法正常完成 TCP/IP 的3次握手。</p><p><code>net.ipv4.tcp_timestamps</code>这个参数默认是开启的，它会复用链接，并去检查这个 IP 包里面的时间是不是比当前的时间大，如果大，那么就丢弃该包(见rfc1323，TCP相关的，网上查到的)，从而造成 SYN-SENT 发送后，没有回应。</p><p>然后检查 Linux A 服务器的时间，发现 Linux 服务器 A 的时间比 B 快了 5 分钟，基本可以确认就是这个问题了</p><p><strong>解决方法</strong>：</p><p>在 Linux 服务器 A 上修改 <code>/etc/sysctl.conf</code> 文件，在最后增加如下内容</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="/etc/sysctl.conf"><span>/etc/sysctl.conf</span></div><div class="language-ssh-config" data-highlighter="shiki" data-ext="ssh-config" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Controls the timestamps check in syn-send</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 0 --&gt; do not check</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 1 --&gt; check</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">net.ipv4.tcp_timestamps = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span></span></code></pre></div></div><p>配置完成后，重载 sysctl 规则</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sysctl</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span></span></code></pre></div><p>随后查看生效情况</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sysctl</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> |</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> timestamp</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">net.ipv4.tcp_timestamps</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span></code></pre></div><p>再在 Linux 服务器 A 上 <code>curl</code> 服务器 B，发现问题解决了。</p>`,18)]))}const c=t(n,[["render",l]]),h=JSON.parse('{"path":"/posts/Config/Linux/FAQ/2019-10-16-%E8%AE%B0%E4%B8%80%E6%AC%A1Linux%E6%9C%8D%E5%8A%A1%E5%99%A8Curl%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E5%8F%A6%E4%B8%80%E5%8F%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95.html","title":"【FAQ】记一次 Linux 服务器 Curl 方式访问另一台 Linux 服务器失败的处理方法","lang":"zh-CN","frontmatter":{"title":"【FAQ】记一次 Linux 服务器 Curl 方式访问另一台 Linux 服务器失败的处理方法","shortTitle":"Linux Curl 命令卡「Client Hello」故障处理","description":"记录 Linux 服务器 Curl 方式访问另一台 Linux 服务器卡在「client hello」的处理方法","icon":"/assets/blogicons/常问问题.png","author":"昌霖学长","isOriginal":true,"date":"2019-10-16T00:00:00.000Z","categories":["Linux","FAQ"],"tags":["FAQ","Linux","CentOS","Curl"],"license":"MIT","sticky":false,"star":false,"article":true,"timeline":true,"comment":false,"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【FAQ】记一次 Linux 服务器 Curl 方式访问另一台 Linux 服务器失败的处理方法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-10-16T00:00:00.000Z\\",\\"dateModified\\":\\"2025-02-11T10:23:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"昌霖学长\\"}]}"],["meta",{"property":"og:url","content":"https://shawnlyu1990.github.io/posts/Config/Linux/FAQ/2019-10-16-%E8%AE%B0%E4%B8%80%E6%AC%A1Linux%E6%9C%8D%E5%8A%A1%E5%99%A8Curl%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E5%8F%A6%E4%B8%80%E5%8F%B0Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"昌霖学长的自习室"}],["meta",{"property":"og:title","content":"【FAQ】记一次 Linux 服务器 Curl 方式访问另一台 Linux 服务器失败的处理方法"}],["meta",{"property":"og:description","content":"记录 Linux 服务器 Curl 方式访问另一台 Linux 服务器卡在「client hello」的处理方法"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T10:23:29.000Z"}],["meta",{"property":"article:author","content":"昌霖学长"}],["meta",{"property":"article:tag","content":"Curl"}],["meta",{"property":"article:tag","content":"CentOS"}],["meta",{"property":"article:tag","content":"Linux"}],["meta",{"property":"article:tag","content":"FAQ"}],["meta",{"property":"article:published_time","content":"2019-10-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-11T10:23:29.000Z"}]]},"git":{"createdTime":1723779818000,"updatedTime":1739269409000,"contributors":[{"name":"Shawn Lyu","username":"","email":"shawnlyu1990@gmail.com","commits":9}]},"readingTime":{"minutes":2.59,"words":778},"filePathRelative":"posts/Config/Linux/FAQ/2019-10-16-记一次Linux服务器Curl方式访问另一台Linux服务器失败的处理方法.md","excerpt":"","copyright":{"license":"MIT"}}');export{c as comp,h as data};
